<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MiniPB: MiniPB</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="overrides.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MiniPB
   &#160;<span id="projectnumber">v0.1.0</span>
   </div>
   <div id="projectbrief">A small header only protobuf writer/reader implemented for C++11 and relying only on the STL</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">MiniPB </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_README"></a>This is minipb, a small header only protobuf writer/reader implemented for C++11 and relying only on the STL.</p>
<h1>Why ?</h1>
<p>Because all protobuf libraries I found fall in two categories:</p><ul>
<li>High performance but bloated and complicated</li>
<li>Embedded (no dynamic allocations, fixed string widths)</li>
</ul>
<p>MiniPB tries to hit somewhat of a middleground. It is implemented in a single header with no dependencies except the stl. The generated code is relatively compact (~4 lines of C++ per protobuf line) and the compiled binary is small enough to be considered noise in any reasonably sized C++ App. It's not the fastest protobuf library out there, but I have written it with performance in mind, so I better hope its not the slowest either. It does use dynamic memory where needed (allocating strings and submessages), but avoids them otherwise. It doesn't implement all of the features protobuf supports (e.g. enums, oneof, ...), but everything important (scalars, messages, string and bytes as well as repeated and packed variants of them) are supported. As far as I know it is fully standards compliant for the features it supports.</p>
<h1>Compiling proto files</h1>
<p>Minipb comes with a plugin for protoc similar to grpc, which can be used to generate implementation files for a proto source.</p>
<h1>Example</h1>
<p>Given the following proto file </p><div class="fragment"><div class="line">syntax = &quot;proto3&quot;;</div>
<div class="line"> </div>
<div class="line">message my_message {</div>
<div class="line">    string field1 = 1;</div>
<div class="line">    my_message field2 = 2;</div>
<div class="line">    repeated float field3 = 3;</div>
<div class="line">}</div>
</div><!-- fragment --><p> Minipb will generate the following c++ type in the header file </p><div class="fragment"><div class="line"><span class="keyword">struct </span>my_message {</div>
<div class="line">  <span class="keywordtype">size_t</span> estimate_size() const noexcept;</div>
<div class="line">  ::minipb::result encode(::minipb::msg_builder&amp; b) const noexcept;</div>
<div class="line">  ::minipb::result decode(::minipb::msg_parser&amp; p) noexcept;</div>
<div class="line"> </div>
<div class="line">  std::<span class="keywordtype">string</span> field1{};</div>
<div class="line">  std::unique_ptr&lt;my_message&gt; field2{};</div>
<div class="line">  std::vector&lt;float&gt; field3{};</div>
<div class="line">};</div>
</div><!-- fragment --><h1>Generated code</h1>
<p>And an additional C++ Source file with the implementations of those functions. </p><div class="fragment"><div class="line"><span class="comment">// Header contents is repeated here</span></div>
<div class="line"><span class="keywordtype">size_t</span> my_message::estimate_size() const noexcept {</div>
<div class="line">  <span class="keywordtype">size_t</span> size {0};</div>
<div class="line">  size += this-&gt;field1.size();</div>
<div class="line">  <span class="keywordflow">if</span>(this-&gt;field2) size += this-&gt;field2-&gt;estimate_size() + 10 + 1;</div>
<div class="line">  size += 5 * (this-&gt;field3.size());</div>
<div class="line">  size += 11;</div>
<div class="line">  <span class="keywordflow">return</span> size;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">::minipb::result my_message::encode(::<a class="code" href="classminipb_1_1msg__builder.html">minipb::msg_builder</a>&amp; b) <span class="keyword">const</span> noexcept {</div>
<div class="line">  b.string_field(1, this-&gt;field1);</div>
<div class="line">  { <span class="keywordflow">if</span>(this-&gt;field2) b.message_field(2, *this-&gt;field2); }</div>
<div class="line">  b.packed_fixed32_field(3, this-&gt;field3);</div>
<div class="line">  <span class="keywordflow">return</span> b.last_error();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">::minipb::result my_message::decode(::<a class="code" href="classminipb_1_1msg__parser.html">minipb::msg_parser</a>&amp; p) noexcept {</div>
<div class="line">  minipb::result res = p.next_field();</div>
<div class="line">  <span class="keywordflow">while</span> (res == minipb::result::ok) {</div>
<div class="line">    <span class="keywordflow">switch</span> (p.field_id()) {</div>
<div class="line">      <span class="keywordflow">case</span> 1: res = p.string_field(this-&gt;field1); <span class="keywordflow">break</span>;</div>
<div class="line">      <span class="keywordflow">case</span> 2: {</div>
<div class="line">        <span class="keywordflow">if</span>(!this-&gt;field2) this-&gt;field2 = std::make_unique&lt;my_message&gt;();</div>
<div class="line">        p.message_field(*this-&gt;field2);</div>
<div class="line">      } <span class="keywordflow">break</span>;</div>
<div class="line">      <span class="keywordflow">case</span> 3: res = p.repeated_float_field(this-&gt;field3); <span class="keywordflow">break</span>;</div>
<div class="line">      <span class="keywordflow">default</span>: res = p.skip_field(); <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (p.is_eof()) <span class="keywordflow">break</span>;</div>
<div class="line">    res = p.next_field();</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> res;</div>
<div class="line">}</div>
<div class="ttc" id="aclassminipb_1_1msg__builder_html"><div class="ttname"><a href="classminipb_1_1msg__builder.html">minipb::msg_builder</a></div><div class="ttdoc">Helper class for building a message from individual fields.</div><div class="ttdef"><b>Definition:</b> minipb.h:506</div></div>
<div class="ttc" id="aclassminipb_1_1msg__parser_html"><div class="ttname"><a href="classminipb_1_1msg__parser.html">minipb::msg_parser</a></div><div class="ttdoc">Class providing an interface for parsing a encoded protobuf message.</div><div class="ttdef"><b>Definition:</b> minipb.h:1045</div></div>
</div><!-- fragment --><p> Note that there are no virtual functions or inheritance. Since all needed information is available at compile time there is no need for them. The function <code>estimate_size()</code> returns a worst case estimate for the serialized size of the message with its current contents and is used for all messages to support serialization. If you consider implementing it yourself, you can simply return 0 and it will still work (but might increase the serialized size). The function can (and usually will) return more than is actually needed for the message, but the message is guaranteed to fit in the returned space. You can therefore use it to (stack-) allocate a buffer to hold the serialized message.</p>
<p>The function <code>encode()</code> can be used to - surprise - encode the message into its serialized form. The only reason it can fail is if theres not enough memory left in the buffer provided or the backing container failed to reallocate (out of memory). Assuming you provided at least <code>estimate_size()</code> bytes, this function is not supposed to fail.</p>
<p>The last function <code>decode()</code> is used to decode a serialized message and fill the struct with its information. Assuming the provided buffer contains a complete and valid protobuf message this should not fail, however it might in case of a schema missmatch or otherwise bad input data. In case an error is returned, the function might leave the message struct in an partially filled state.</p>
<h1>Extending</h1>
<p>By default the libary can use both preallocated raw arrays, as well as selected stl containers for both input and output. However you can add a custom implementation in order to support whatever datatype/device you need. </p><div class="fragment"><div class="line"><span class="keyword">class </span>input_stream {</div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    ~input_stream() = <span class="keywordflow">default</span>;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> result read(<span class="keywordtype">void</span>* data, <span class="keywordtype">size_t</span> data_size) noexcept = 0;</div>
<div class="line">    <span class="keyword">virtual</span> result skip(<span class="keywordtype">size_t</span> data_size) noexcept = 0;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">size_t</span> peek(<span class="keywordtype">void</span>*, <span class="keywordtype">size_t</span>) noexcept { <span class="keywordflow">return</span> 0; }</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">size_t</span> bytes_available() const noexcept = 0;</div>
<div class="line">};</div>
</div><!-- fragment --><p> <code>read()</code> is used to read the given amount of data into the buffer. If the requested amount exceeds the available data an error should be returned. Minipb will then bubble up the error all the way to user code. <code>skip()</code> is similar to read but ignores the data. <code>peek</code> can be implemented in case the data provider supports it and looking ahead without actually reading the data is cheap (e.g. in a contigous array). Peek data will not be removed from the stream and needs to get returned at a subsequent <code>read()</code> or skipped. Peeks do not accumulate, meaning that two calls to <code>peek()</code> without an intermediate <code>read()</code> or <code>skip()</code> should return the same data. If <code>peek()</code> is not supported by the backend, you can return 0, otherwise return the size of the read data. If peek returns less than data_size, but not 0 the library assumes eof after the returned size. In case 0 is returned minipb will fall back to doing (potentially lots of) single byte reads. A pattern that can be seen often is the library doing a peek for 10 bytes (max size of a varint) followed by a skip of the actual varint size. This avoids having to do up to 10 single byte reads. <code>bytes_available()</code> should return the remaining number of bytes left in the serialized message. Because protobuf has no indication of record end, minipb will try to parse data until bytes_available() is 0.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>output_stream {</div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    ~output_stream() = <span class="keywordflow">default</span>;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">size_t</span> position() const noexcept = 0;</div>
<div class="line">    virtual result write(const <span class="keywordtype">void</span>* data, <span class="keywordtype">size_t</span> data_size) noexcept = 0;</div>
<div class="line">    virtual result write_at(<span class="keywordtype">size_t</span> pos, const <span class="keywordtype">void</span>* data, <span class="keywordtype">size_t</span> data_size) noexcept = 0;</div>
<div class="line">};</div>
</div><!-- fragment --><p> The output stream is used when serializing a message to a byte stream. It consists of 3 functions, all of which need to get implemented. The <code>position()</code> function should return the total number of bytes written using this stream. It is used to calculate sizes and as a marker for calling <code>write_at()</code>. The function <code>write()</code> is called whenever the library wants to emit some data. The function should write all the provided data or return an error if it can't. <code>write_at()</code> is used to overwrite a previously written block of data. This is needed since the exact size of a submessage is not known until after it has been serialized in order to patch the length field in the header. Protobuf supports an alternate method of delimiting messages called "groups" which would allow us to skip the patching, however they have already been deprecated when protobuf was publically released and as a result many implementations don't support them. I might provide a option to use them instead of length delimited messages in the future, allowing for true buffer less forward only serialization at the cost of compatibility. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
